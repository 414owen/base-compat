all :: Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
and :: Foldable t => t GHC.Types.Bool -> GHC.Types.Bool
any :: Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Types.Bool
asum :: (Foldable t, GHC.Base.Alternative f) => t (f a) -> f a
concat :: Foldable t => t [a] -> [a]
concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
elem :: (GHC.Classes.Eq a, Foldable t) => a -> t a -> GHC.Types.Bool
find :: Foldable t => (a -> GHC.Types.Bool) -> t a -> GHC.Base.Maybe a
fold :: (Foldable t, GHC.Base.Monoid m) => t m -> m
foldl :: Foldable t => (b -> a -> b) -> b -> t a -> b
foldl' :: Foldable t => (b -> a -> b) -> b -> t a -> b
foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
foldlM :: (GHC.Base.Monad m, Foldable t) =>    (b -> a -> m b) -> b -> t a -> m b
foldMap :: (Foldable t, GHC.Base.Monoid m) => (a -> m) -> t a -> m
foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
foldrM :: (GHC.Base.Monad m, Foldable t) =>    (a -> b -> m b) -> b -> t a -> m b
for_ :: (GHC.Base.Applicative f, Foldable t) =>    t a -> (a -> f b) -> f ()
forM_ :: (GHC.Base.Monad m, Foldable t) => t a -> (a -> m b) -> m ()
length :: Foldable t => t a -> GHC.Types.Int
mapM_ :: (GHC.Base.Monad m, Foldable t) => (a -> m b) -> t a -> m ()
maximum :: (GHC.Classes.Ord a, Foldable t) => t a -> a
maximumBy :: Foldable t => (a -> a -> GHC.Types.Ordering) -> t a -> a
minimum :: (GHC.Classes.Ord a, Foldable t) => t a -> a
minimumBy :: Foldable t => (a -> a -> GHC.Types.Ordering) -> t a -> a
msum :: (Foldable t, GHC.Base.MonadPlus m) => t (m a) -> m a
notElem :: (GHC.Classes.Eq a, Foldable t) => a -> t a -> GHC.Types.Bool
null :: Foldable t => t a -> GHC.Types.Bool
or :: Foldable t => t GHC.Types.Bool -> GHC.Types.Bool
product :: (GHC.Num.Num a, Foldable t) => t a -> a
sequence_ :: (GHC.Base.Monad m, Foldable t) => t (m a) -> m ()
sequenceA_ :: (GHC.Base.Applicative f, Foldable t) => t (f a) -> f ()
sum :: (GHC.Num.Num a, Foldable t) => t a -> a
toList :: Foldable t => t a -> [a]
traverse_ :: (GHC.Base.Applicative f, Foldable t) =>    (a -> f b) -> t a -> f ()
